time.col <- grep("Time", fields)
# Read minilog data:
x <- read.table(file = file, header = TRUE, skip = k, sep = ",", colClasses = "character", fileEncoding = "Windows-1252")
if (ncol(x) == 1) x <- read.table(file = file, header = TRUE, skip = k, sep = "\t", colClasses = "character", fileEncoding = "Windows-1252")
# Separate date and time fields:
if (length(c(grep("Date", fields[1]), grep("Time", fields[1]))) == 2){
fields <- c(strsplit(fields[1], " ", fixed = TRUE), fields[2:length(fields)])
fields <- unlist(fields)
names(fields) <- NULL
temp <- unlist(strsplit(x[,1], " |\t"))
temp <- data.frame(date = temp[seq(1, length(temp), by = 2)],
time = temp[seq(2, length(temp), by = 2)], stringsAsFactors = FALSE)
x <- cbind(temp, x[, 2:dim(x)[2]])
time.col <- 2
}
# Parse date fields:
date <- NULL
sep <- unique(strsplit(gsub("[0-9]", "", x[1, date.col]), "")[[1]])
if (nchar(strsplit(x[1, date.col], sep)[[1]][3]) == 4) date.format <- "dd-mm-yyyy"
if (length(date.format) > 0){
if (date.format == "dd-mm-yyyy") ii <- c(3, 2, 1)
if (date.format == "mm-dd-yyyy") ii <- c(3, 1, 2)
if (date.format == "yyyy-mm-dd") ii <- c(1, 2, 3)
date <- data.frame(year = as.numeric(unlist(lapply(strsplit(x[, date.col], sep), function(x) x[ii[1]]))),
month = as.numeric(unlist(lapply(strsplit(x[, date.col], sep), function(x) x[ii[2]]))),
day = as.numeric(unlist(lapply(strsplit(x[, date.col], sep), function(x) x[ii[3]]))),
stringsAsFactors = FALSE)
}
if (is.null(date)) stop(paste("Unrecognized data format:", date.format))
# Parse time field:
sep <- unique(strsplit(gsub("[0-9]", "", x[1, time.col]), "")[[1]])
time <- data.frame(hour = as.numeric(unlist(lapply(strsplit(x[, time.col], sep), function(x) x[1]))),
minute = as.numeric(unlist(lapply(strsplit(x[, time.col], sep), function(x) x[2]))),
second = as.numeric(unlist(lapply(strsplit(x[, time.col], sep), function(x) x[3]))),
stringsAsFactors = FALSE)
# Create column index for measured data:
index <- setdiff(1:length(fields), c(time.col, date.col))
# Convert data to numeric format:
for (i in 1:length(index)) x[, index[i]] <- as.numeric(as.character(x[, index[i]]))
# Create data frame containing minilog data:
x <- cbind(date, time, x[, index])
# Convert data field names to proper format:
fields <- fields[index]
fields <- unlist(lapply(strsplit(as.character(fields), "(", fixed = TRUE), function(x) x[[1]][1]))
fields <- gsub(" ", "", fields)
# Assign column names:
names(x) <- c(names(x)[1:6], tolower(fields))
str <- names(header)
str[str == "Study.ID"] <- "tow.id"
names(header) <- str
# Define survey string:
if ("Study.Description" %in% names(header)){
if (length(grep("^GP", header$Study.Description)) > 0) header$tow.id <- header$Study.Description
}
# Substitute 'meters' and 'celsius' by 'depth' and 'temperature':
str <- names(x)
str[str == "meters"] <- "depth"
str[str == "celsius"] <- "temperature"
names(x) <- str
# Modify time by specified offset:
if (offset != 0){
t <- as.matrix(as.POSIXlt(time(x) + offset * 60))
x$year   <- t[, "year"] + 1900
x$month  <- t[, "mon"] + 1
x$day    <- t[, "mday"]
x$hour   <- t[, "hour"]
x$minute <- t[, "min"]
x$second <- t[, "sec"]
}
# Include 'tow.id' as a field:
x$tow.id <- header$tow.id
offset = 0
# Define list of files to be read:
if (missing(file)) file <- minilog.file.str(x, survey = survey, ...)
# Read multiple minilog files and concatenate them:
if (length(file) == 0) return(NULL)
if (length(file) > 1){
x <- NULL
for (i in 1:length(file)){
cat(paste(i, ") Reading: '", file[i], "'\n", sep = ""))
temp <- read.minilog(file[i], ...)
for (j in 1:length(header(temp))){
temp[, names(header(temp))[j]] <- header(temp)[[names(header(temp))[j]]]
}
# Add columns if necessary:
if ((length(setdiff(names(temp), names(x))) > 0) & (!is.null(x))){
x[setdiff(names(temp), names(x))] <- NA
x <- x[names(temp)]
}
# Append rows:
x <- rbind(x, temp)
}
temp <- attributes(x)
temp <- temp[setdiff(names(temp), names(header(x)))]
attributes(x) <- temp
if ("Study.ID" %in% names(x)) x$Study.ID <- unlist(lapply(strsplit(x$Study.ID, " "), function(x) x[[1]]))
return(x)
}
# Read and parse header info:
y <- read.table(file = file, nrow = 10, colClasses = "character", sep = "\n")
k <- sum(substr(y[,1], 1, 1) == "*") - 1 # Number of header lines.
if (k <= 0){
k <- sum(substr(y[,1], 1, 1) %in% c(letters, LETTERS))-1
y[1:(k+1),1] <- paste("*", y[1:(k+1),1])
}
y <- substr(y[1:k, 1], 3, 100) # Eliminate leading characters.
y <- gsub("\t", "", y)
y <- strsplit(y, "([:][ ])|([=])") # Split header fields and their values.
header <- list()
fields <- NULL
for (i in 1:k){
fields[i] <- gsub(" ", ".", y[[i]][1])
header[[i]] <- y[[i]][2]
}
str <- strsplit(file, "/")[[1]]
header <- c(header, str[length(str)])
names(header) <- c(fields, "file.name")
# Read field variable names:
fields <- read.table(file = file, header = FALSE, skip = k, nrows = 1,
sep = ",", colClasses = "character", fileEncoding = "Windows-1252")
fields <- t(fields)[, 1]
fields <- unlist(strsplit(fields, "\t"))
fields <- gsub(" ", "", fields, fixed = TRUE)
names(fields) <- NULL
# Determine date column and format:
date.col <- grep("Date", fields)
date.format <- substr(fields[date.col],
regexpr("(", fields[date.col], fixed = TRUE)[1] + 1,
regexpr(")", fields[date.col], fixed = TRUE)[1] - 1)
# Determine time column:
time.col <- grep("Time", fields)
# Read minilog data:
x <- read.table(file = file, header = TRUE, skip = k, sep = ",", colClasses = "character", fileEncoding = "Windows-1252")
if (ncol(x) == 1) x <- read.table(file = file, header = TRUE, skip = k, sep = "\t", colClasses = "character", fileEncoding = "Windows-1252")
# Separate date and time fields:
if (length(c(grep("Date", fields[1]), grep("Time", fields[1]))) == 2){
fields <- c(strsplit(fields[1], " ", fixed = TRUE), fields[2:length(fields)])
fields <- unlist(fields)
names(fields) <- NULL
temp <- unlist(strsplit(x[,1], " |\t"))
temp <- data.frame(date = temp[seq(1, length(temp), by = 2)],
time = temp[seq(2, length(temp), by = 2)], stringsAsFactors = FALSE)
x <- cbind(temp, x[, 2:dim(x)[2]])
time.col <- 2
}
# Parse date fields:
date <- NULL
sep <- unique(strsplit(gsub("[0-9]", "", x[1, date.col]), "")[[1]])
if (nchar(strsplit(x[1, date.col], sep)[[1]][3]) == 4) date.format <- "dd-mm-yyyy"
if (length(date.format) > 0){
if (date.format == "dd-mm-yyyy") ii <- c(3, 2, 1)
if (date.format == "mm-dd-yyyy") ii <- c(3, 1, 2)
if (date.format == "yyyy-mm-dd") ii <- c(1, 2, 3)
date <- data.frame(year = as.numeric(unlist(lapply(strsplit(x[, date.col], sep), function(x) x[ii[1]]))),
month = as.numeric(unlist(lapply(strsplit(x[, date.col], sep), function(x) x[ii[2]]))),
day = as.numeric(unlist(lapply(strsplit(x[, date.col], sep), function(x) x[ii[3]]))),
stringsAsFactors = FALSE)
}
if (is.null(date)) stop(paste("Unrecognized data format:", date.format))
# Parse time field:
sep <- unique(strsplit(gsub("[0-9]", "", x[1, time.col]), "")[[1]])
time <- data.frame(hour = as.numeric(unlist(lapply(strsplit(x[, time.col], sep), function(x) x[1]))),
minute = as.numeric(unlist(lapply(strsplit(x[, time.col], sep), function(x) x[2]))),
second = as.numeric(unlist(lapply(strsplit(x[, time.col], sep), function(x) x[3]))),
stringsAsFactors = FALSE)
# Create column index for measured data:
index <- setdiff(1:length(fields), c(time.col, date.col))
# Convert data to numeric format:
for (i in 1:length(index)) x[, index[i]] <- as.numeric(as.character(x[, index[i]]))
# Create data frame containing minilog data:
x <- cbind(date, time, x[, index])
# Convert data field names to proper format:
fields <- fields[index]
fields <- unlist(lapply(strsplit(as.character(fields), "(", fixed = TRUE), function(x) x[[1]][1]))
fields <- gsub(" ", "", fields)
# Assign column names:
names(x) <- c(names(x)[1:6], tolower(fields))
str <- names(header)
str[str == "Study.ID"] <- "tow.id"
names(header) <- str
# Define survey string:
if ("Study.Description" %in% names(header)){
if (length(grep("^GP", header$Study.Description)) > 0) header$tow.id <- header$Study.Description
}
# Substitute 'meters' and 'celsius' by 'depth' and 'temperature':
str <- names(x)
str[str == "meters"] <- "depth"
str[str == "celsius"] <- "temperature"
names(x) <- str
# Modify time by specified offset:
if (offset != 0){
t <- as.matrix(as.POSIXlt(time(x) + offset * 60))
x$year   <- t[, "year"] + 1900
x$month  <- t[, "mon"] + 1
x$day    <- t[, "mday"]
x$hour   <- t[, "hour"]
x$minute <- t[, "min"]
x$second <- t[, "sec"]
}
# Include 'tow.id' as a field:
x$tow.id <- header$tow.id
head(x)
z <- x
# Remove non-minilog variables:
names(x) <- tolower(names(x))
head(x)
names(x) <- tolower(names(x))
vars <- c("date", "time", "temperature", "depth")
x <- x[, intersect(vars, names(x))]
head(x)
x <- z
names(x) <- tolower(names(x))
vars <- c("date", "time", "temperature", "depth")
intersect(vars, names(x))
date(x)
library(gulf.utils)
date(x)
head(x)
dir(path = "data/raw/minilog", full.names = TRUE)
library(gulf.data)
files <- dir(path = "data/raw/minilog", full.names = TRUE)
x <- read.minilog(file = files[1], project = "collectors")
library(gulf.utils)
library(gulf.data)
files <- dir(path = "data/raw/minilog", full.names = TRUE)
x <- read.minilog(file = files[1], project = "collectors")
plot(time(x), x$temperature, pch = 21, bg = "grey", cex = 0.5, xlab = "Date", ylab = "Temperature")
time(x)
file
files
header(x)
plot(time(x), x$temperature, pch = 21, bg = "grey", cex = 0.5,
xlab = "Date", ylab = "Temperature", main = header(x)$Study.Description)
install_github("ropenscilabs/emldown")
devtools::install_github("ropenscilabs/emldown")
getwd()
render_eml(metadata\site.xml")
render_eml("metadata\site.xml")
render_eml("metadata/site.xml")
library(emldown)
render_eml("metadata/site.xml")
help(render_eml)
render_eml("metadata/site.xml", outfile = "site.html", output_dir = "metadata")
render_eml("metadata/site.xml", outfile = "site.html", output_dir = "/metadata")
render_eml("metadata/site.xml", outfile = "site.html", output_dir = "metadata/")
source('~/Desktop/lobster-collectors/metadata/metadata.R', echo=TRUE)
render_eml("metadata/site.xml", outfile = "site.html", output_dir = "/metadata/")
install.packages(c("assertthat", "backports", "BH", "bookdown", "boot", "Cairo", "callr", "class", "cli", "clipr", "cluster", "coda", "codetools", "colorspace", "commonmark", "crosstalk", "curl", "deldir", "Deriv", "devtools", "digest", "doParallel", "dplyr", "evaluate", "expm", "fansi", "fields", "foreach", "foreign", "fs", "ggplot2", "gh", "git2r", "glue", "gtable", "gtools", "highr", "htmltools", "htmlwidgets", "httpuv", "httr", "igraph", "isoband", "iterators", "jsonlite", "KernSmooth", "knitr", "later", "lattice", "lazyeval", "loo", "manipulateWidget", "markdown", "MASS", "Matrix", "matrixStats", "mcmc", "mgcv", "mime", "mnormt", "mvtnorm", "nimble", "nlme", "nnet", "numDeriv", "officer", "openssl", "permute", "pillar", "pkgbuild", "pkgconfig", "plyr", "polynom", "prettyunits", "processx", "promises", "ps", "purrr", "quantreg", "R6", "raster", "rcmdcheck", "Rcpp", "RcppEigen", "remotes", "reshape2", "rgdal", "rgl", "rjags", "rmarkdown", "RODBC", "rpart", "rstan", "rstudioapi", "scales", "shiny", "sn", "sp", "spam", "SparseM", "spData", "spdep", "StanHeaders", "stringi", "stringr", "survival", "tibble", "tidyselect", "tinytex", "TMB", "usethis", "uuid", "vegan", "webshot", "whisker", "withr", "xfun", "xml2", "xslt", "xtable", "yaml", "zip"))
library(gulf.utils)
library(gulf.data)
files = dir.github(username = 'TobieSurette', repo = 'lobster-collectors')
files <- files[intersect(grep('minilog', files), grep('2019', files))]
x <- read.minilog(file = files[1])
x
header(x)
t(header(x))
t(header(x))[, 1]
t(header(x))
describe(x)
source('~/Desktop/gulf.data/R/minilog.R', echo=TRUE)
source('~/Desktop/gulf.data/R/read.minilog.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
attributes(x)
library(gulf.utils)
library(gulf.data)
files = dir.github(username = 'TobieSurette', repo = 'lobster-collectors')
files <- files[intersect(grep('minilog', files), grep('2019', files))]
x <- read.minilog(file = files[1])
head(x)
units(x)
x <- read.minilog(file = files[1:2])
x <- read.minilog(file = files)
dim(x)
head(x)
x <- read.minilog(file = files[1])
attributes(x)
x <- read.minilog(file = files[1])
i = 1
tmp <- read.minilog(file = files[i])
header(tmp)
header(tmp)$Source.Device
x <- NULL
for (i in 1:length(files)){
tmp <- read.minilog(file = files[i])
tmp$device <- as.character(header(tmp)$Source.Device)
x  <- rbind(x, tmp)
}
x <- NULL
for (i in 1:length(files)){
tmp <- read.minilog(file = files[i])
tmp$device <- as.character(header(tmp)$Source.Device)
x  <- rbind(x, tmp)
print(as.character(header(tmp)$Study.Description))
}
str <- as.character(header(tmp)$Study.Description)
strplit(str, sep = "2019")
str <- as.character(header(tmp)$Study.Description)
strsplit(str, sep = "2019")
strsplit(str, "2019")
strsplit(str, "2019")[[1]][1]
str <- as.character(header(tmp)$Study.Description)
strsplit(str, " 2019")[[1]][1]
x <- NULL
for (i in 1:length(files)){
tmp <- read.minilog(file = files[i])
tmp$device <- as.character(header(tmp)$Source.Device)
str <- as.character(header(tmp)$Study.Description)
str <- strsplit(str, " 2019")[[1]][1]
tmp$site <- str
x  <- rbind(x, tmp)
}
head(x)
tmp <- read.minilog(file = files[i])
device <- as.character(header(tmp)$Source.Device)
site <- as.character(header(tmp)$Study.Description)
site <- strsplit(str, " 2019")[[1]][1]
site <- str
tmp <- cbind(device = device, site = site, tmp)
head(tmp)
describe(x)
describe(tmp)
files = dir.github(username = 'TobieSurette', repo = 'lobster-collectors')
files <- files[intersect(grep('minilog', files), grep('2019', files))]
x <- NULL
for (i in 1:length(files)){
tmp <- read.minilog(file = files[i])
device <- as.character(header(tmp)$Source.Device)
site <- as.character(header(tmp)$Study.Description)
site <- strsplit(str, " 2019")[[1]][1]
site <- str
tmp <- cbind(device = device, site = site, tmp)
x  <- rbind(x, tmp)
}
key(x)
attributes(x)
class(x)
source('~/Desktop/lobster-collectors/export/minilog.R', echo=TRUE)
files
library(gulf.data)
locate("collector.csv")
getwd()
locate(pattern = "collector.csv")
read.csv("data/collector.csv", header = TRUE, stringsAsFactors = FALSE)
library(gulf.data)
locate(pattern = "collector.csv")
x <- read.csv("data/collector.csv", header = TRUE, stringsAsFactors = FALSE)
head(x)
x <- read.csv("data/biological.csv", header = TRUE, stringsAsFactors = FALSE)
table(x$year, x$site)
head(x)
x$size
table(x$year, x$site)
x$species
head(x)
x <- read.csv("data/biological.csv", header = TRUE, stringsAsFactors = FALSE)
x <- x$species == "Homarus americanus"
x <- read.csv("data/biological.csv", header = TRUE, stringsAsFactors = FALSE)
x <- x[x$species == "Homarus americanus", ]
table(x$year, x$site)
x <- x[x$year == 2019, ]
head(x)
dim(x)
x$carapace.width
x$ssize
x$size
library(gulf.graphics)
x <- read.csv("data/biological.csv", header = TRUE, stringsAsFactors = FALSE)
x <- x[x$species == "Homarus americanus", ]
x <- x[x$year == 2019, ]
table(x$size)
gbarplot(table(x$size))
gbarplot(table(x$size), width = 0.1)
gbarplot(table(x$size), width = 0.1, xlab = "Carapace length(mm)", ylab = "Frequency")
x <- x[x$year == 2018, ]
gbarplot(table(x$size), width = 0.1, xlab = "Carapace length(mm)", ylab = "Frequency")
x <- read.csv("data/biological.csv", header = TRUE, stringsAsFactors = FALSE)
x <- x[x$species == "Homarus americanus", ]
x <- x[x$year == 2018, ]
gbarplot(table(x$size), width = 0.1, xlab = "Carapace length(mm)", ylab = "Frequency")
x <- read.csv("data/biological.csv", header = TRUE, stringsAsFactors = FALSE)
x <- x[x$species == "Homarus americanus", ]
x <- x[x$year == 2017, ]
gbarplot(table(x$size), width = 0.1, xlab = "Carapace length(mm)", ylab = "Frequency")
x <- read.csv("data/biological.csv", header = TRUE, stringsAsFactors = FALSE)
x <- x[x$species == "Homarus americanus", ]
x <- x[x$year == 2016, ]
gbarplot(table(x$size), width = 0.1, xlab = "Carapace length(mm)", ylab = "Frequency")
x <- read.csv("data/biological.csv", header = TRUE, stringsAsFactors = FALSE)
x <- x[x$species == "Homarus americanus", ]
x <- x[x$year == 2015, ]
gbarplot(table(x$size), width = 0.1, xlab = "Carapace length(mm)", ylab = "Frequency")
x <- read.csv("data/biological.csv", header = TRUE, stringsAsFactors = FALSE)
x <- x[x$species == "Homarus americanus", ]
x <- x[x$year == 2019, ]
gbarplot(table(x$size), width = 0.1, xlab = "Carapace length(mm)", ylab = "Frequency")
library(gulf.data)
library(gulf.utils)
library(gulf.data)
files <- dir(path = "data/raw/minilog", full.names = TRUE)
# Read the first file:
x <- read.minilog(file = files[1], project = "collectors")
# Plot the first file:
plot(time(x), x$temperature, pch = 21, bg = "grey", cex = 0.5,
xlab = "Date", ylab = "Temperature", main = header(x)$Study.Description)
library(gulf)
language <- "french"
jpeg <- FALSE
# Load data file HERE:
# read.csv(filename, )
# data file is assumed to have 'year', 'site' and 'n' fields:
data <- read.csv("/Users/crustacean/Desktop/lobster-collectors/data/Biological.csv", stringsAsFactors = FALSE)
names(data) <- tolower(names(data))
data$n <- data$nyoy
# Treat missing values as zero yoy observations:
data$n[is.na(data$n)] <- 0
# Site reformats:
data$site <- gsub("Fortune[12]", "Fortune", data$site) # Combine Fortune sites.
data$site[data$site %in% c("Skinner's pond", "Skinner's Pond ")] <- "Skinner's Pond"
# Keep track of sites in years with no observations:
zeroes <- aggregate(list(mean = data[,"n"]), by = data[c("site", "year")], mean)
zeroes <- zeroes[zeroes$mean == 0, ]
# Remove null sites from analysis:
data <- data[is.na(match(data[c("site", "year")], zeroes[c("site", "year")])), ]
data$site <- as.factor(data$site)
data$year <- factor(data$year, levels = sort(unique(data$year)))
# Fit model:
m <- glm(n ~ site * year, family = poisson, data = data)
# Calculate indices:
newdata <- aggregate(data["n"], by = data[c("site", "year")], mean)
newdata <- newdata[newdata$n > 0, 1:2]
res <- predict(m, newdata = newdata, se.fit = TRUE)
# Compile results:
results <- data.frame(mean = exp(res$fit),
lower.ci = exp(res$fit - 1.96 * res$se.fit),
upper.ci = exp(res$fit + 1.96 * res$se.fit))
results <- cbind(newdata, results / 0.557) # Standardize to one square meter.
# Add zeroes to results:
zeroes$lower.ci <- 0
zeroes$upper.ci <- 0
results <- rbind(results, zeroes)
sites <- unique(results$site)
cols <- rainbow(length(sites))
results$year <- as.numeric(as.character(results$year))
results <- sort(results, by = c("site", "year"))
# Quick plot:
windows()
plot(range(results$year), c(0, 1.2*max(results$mean)), type = "n")
for (i in 1:length(sites)){
r <- results[results$site == sites[i], ]
print(r)
lines(r$year, r$mean, col = cols[i], lwd = 2)
}
legend("topleft", legend = sites, col = cols, lwd = 2)
if (jpeg){
jpeg(filename = paste0("Lobster Yoy Abundance Collector - ", language, ".jpeg"), width = 600 * 8, height = 600 * 8, res = 75 * 8)
}else{
clg()
windows(width = 8.5, height = 8.5)
}
m <- kronecker(matrix(1:2, ncol = 1), matrix(1, ncol = 5, nrow = 5))
m <- rbind(0, cbind(0, m, 0), 0, 0)
layout(m)
par(mar = c(0,0,0,0))  #   c(bottom, left, top, right)
sites <- c("Alberton", "Covehead", "Skinner's Pond", "Egmont Bay", "Fortune", "Murray Harbour",  "Arisaig", "Neguac", "Nine Mile Creek")
results$site <- as.character(results$site)
lty <- c("solid", "dashed", "dotted")
cols <- c("black", "grey40", "grey70")
pch <- 21:23
# Define axis labels:
if (language == "english") xlab <- "Year" else xlab <- "Ann?e"
if (language == "english") ylab <- expression(paste("Number per m"^"2")) else ylab <- expression(paste("Nombre par m"^"2"))
xlim <- range(results$year)
for (i in 1:2){
jj <- (i-1)*3 + (1:3)
if (i == 3) jj <- jj[c(1, 3)]
ylim <- c(0, 1.1 * max(results$upper.ci[results$site %in% sites[jj]]))
plot(xlim, ylim, type = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "", yaxs = "i")
grid()
for (j in 1:length(jj)){
r <- results[results$site %in% sites[jj][j], ]
missing <- setdiff(min(r$year):max(r$year), r$year)
if (length(missing) > 0){
r <- rbind(r, data.frame(site = r$site[1], year = missing, mean = NA, lower.ci = NA, upper.ci = NA))
r <- r[order(r$year), ]
}
lines(r$year, r$mean, col = cols[j], lwd = 2, lty = lty[j])
for (k in 1:nrow(r)){
lines(rep(r$year[k], 2), c(r$lower.ci[k], r$upper.ci[k]), col = cols[j], lty = lty[j], lwd = 2)
lines(c(r$year[k] - 0.10, r$year[k] + 0.10), rep(r$lower.ci[k], 2), col = cols[j], lty = lty[j], lwd = 2)
lines(c(r$year[k] - 0.10, r$year[k] + 0.10), rep(r$upper.ci[k], 2), col = cols[j], lty = lty[j], lwd = 2)
}
}
other <- c("24", "24", "25N", "25S", "26APEI", "26APEI")
str <- sites[jj]
if (language == "french") str <- gsub("Egmont Bay", "Baie Egmont", str)
legend("topleft", legend = paste0(str, " (", other[jj], ")"), col = cols[1:length(jj)], lwd = 2, bg = "white", cex = 1.6, lty = lty[1:length(jj)],
pch = pch[1:length(jj)], pt.bg = cols[1:length(jj)])
if (i == 1) at <- seq(0, 35, by = 5)
if (i == 2) at <- seq(0, 5, by = 1)
if (i == 3) at <- seq(0, 2, by = 0.5)
axis(2, at = at, cex.axis = 1.2)
if (i == 1) mtext(ylab, 2, 3, at = 0, cex = 1.5)
box()
for (j in 1:length(jj)){
r <- results[results$site %in% sites[jj][j], ]
points(r$year, r$mean, pch = pch[j], bg = cols[j], cex = 1.75)
}
}
axis(1, at = seq(min(results$year), max(results$year), by = 2), cex.axis = 1.2)
axis(1, at = seq(min(results$year)+1, max(results$year), by = 2), cex.axis = 1.2)
mtext(xlab, 1, 3.5, cex = 1.5)
if (jpeg) dev.off()
